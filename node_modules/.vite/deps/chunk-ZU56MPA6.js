import {
  LitElement,
  UiHelperUtil,
  css,
  customElement,
  html,
  initializeTheming,
  state
} from "./chunk-EBTJH5Z7.js";
import {
  proxy,
  ref,
  subscribe
} from "./chunk-U6O6RVJR.js";
import {
  require_shim
} from "./chunk-EGQMEMFF.js";
import {
  require_react
} from "./chunk-NTU3EDRZ.js";
import {
  __toESM
} from "./chunk-ANIWD3T6.js";

// node_modules/valtio/esm/vanilla/utils.mjs
function subscribeKey(proxyObject, key, callback, notifyInSync) {
  let prevValue = proxyObject[key];
  return subscribe(
    proxyObject,
    () => {
      const nextValue = proxyObject[key];
      if (!Object.is(prevValue, nextValue)) {
        callback(prevValue = nextValue);
      }
    },
    notifyInSync
  );
}
var DEVTOOLS = Symbol();

// node_modules/valtio/esm/react/utils.mjs
var import_react2 = __toESM(require_react(), 1);

// node_modules/valtio/esm/react.mjs
var import_react = __toESM(require_react(), 1);
var import_shim = __toESM(require_shim(), 1);
var { use } = import_react.default;
var { useSyncExternalStore } = import_shim.default;

// node_modules/@web3modal/core/dist/esm/src/utils/ConstantsUtil.js
var ConstantsUtil = {
  FOUR_MINUTES_MS: 24e4,
  TEN_SEC_MS: 1e4,
  ONE_SEC_MS: 1e3,
  RESTRICTED_TIMEZONES: [
    "ASIA/SHANGHAI",
    "ASIA/URUMQI",
    "ASIA/CHONGQING",
    "ASIA/HARBIN",
    "ASIA/KASHGAR",
    "ASIA/MACAU",
    "ASIA/HONG_KONG",
    "ASIA/MACAO",
    "ASIA/BEIJING",
    "ASIA/HARBIN"
  ]
};

// node_modules/@web3modal/core/dist/esm/src/utils/CoreHelperUtil.js
var CoreHelperUtil = {
  isMobile() {
    if (typeof window !== "undefined") {
      return Boolean(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent));
    }
    return false;
  },
  isAndroid() {
    const ua = navigator.userAgent.toLowerCase();
    return CoreHelperUtil.isMobile() && ua.includes("android");
  },
  isIos() {
    const ua = navigator.userAgent.toLowerCase();
    return CoreHelperUtil.isMobile() && (ua.includes("iphone") || ua.includes("ipad"));
  },
  isClient() {
    return typeof window !== "undefined";
  },
  isPairingExpired(expiry) {
    return expiry ? expiry - Date.now() <= ConstantsUtil.TEN_SEC_MS : true;
  },
  isAllowedRetry(lastRetry) {
    return Date.now() - lastRetry >= ConstantsUtil.ONE_SEC_MS;
  },
  copyToClopboard(text) {
    navigator.clipboard.writeText(text);
  },
  getPairingExpiry() {
    return Date.now() + ConstantsUtil.FOUR_MINUTES_MS;
  },
  getPlainAddress(caipAddress) {
    return caipAddress.split(":")[2];
  },
  async wait(milliseconds) {
    return new Promise((resolve) => {
      setTimeout(resolve, milliseconds);
    });
  },
  debounce(func, timeout = 500) {
    let timer = void 0;
    return (...args) => {
      function next() {
        func(...args);
      }
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(next, timeout);
    };
  },
  isHttpUrl(url) {
    return url.startsWith("http://") || url.startsWith("https://");
  },
  formatNativeUrl(appUrl, wcUri) {
    if (CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatUniversalUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    if (!safeAppUrl.includes("://")) {
      safeAppUrl = appUrl.replaceAll("/", "").replaceAll(":", "");
      safeAppUrl = `${safeAppUrl}://`;
    }
    if (!safeAppUrl.endsWith("/")) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    return {
      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
      href: safeAppUrl
    };
  },
  formatUniversalUrl(appUrl, wcUri) {
    if (!CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatNativeUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    if (!safeAppUrl.endsWith("/")) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    return {
      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
      href: safeAppUrl
    };
  },
  openHref(href, target) {
    window.open(href, target, "noreferrer noopener");
  },
  async preloadImage(src) {
    const imagePromise = new Promise((resolve, reject) => {
      const image = new Image();
      image.onload = resolve;
      image.onerror = reject;
      image.crossOrigin = "anonymous";
      image.src = src;
    });
    return Promise.race([imagePromise, CoreHelperUtil.wait(2e3)]);
  },
  formatBalance(balance, symbol) {
    var _a;
    let formattedBalance = void 0;
    if (balance === "0") {
      formattedBalance = "0.000";
    } else if (typeof balance === "string") {
      const number = Number(balance);
      if (number) {
        formattedBalance = (_a = number.toString().match(/^-?\d+(?:\.\d{0,3})?/u)) == null ? void 0 : _a[0];
      }
    }
    return formattedBalance ? `${formattedBalance} ${symbol}` : "0.000";
  },
  isRestrictedRegion() {
    try {
      const { timeZone } = new Intl.DateTimeFormat().resolvedOptions();
      const capTimeZone = timeZone.toUpperCase();
      return ConstantsUtil.RESTRICTED_TIMEZONES.includes(capTimeZone);
    } catch {
      return false;
    }
  },
  getApiUrl() {
    return CoreHelperUtil.isRestrictedRegion() ? "https://api.web3modal.org" : "https://api.web3modal.com";
  },
  getBlockchainApiUrl() {
    return CoreHelperUtil.isRestrictedRegion() ? "https://rpc.walletconnect.org" : "https://rpc.walletconnect.com";
  },
  getAnalyticsUrl() {
    return CoreHelperUtil.isRestrictedRegion() ? "https://pulse.walletconnect.org" : "https://pulse.walletconnect.com";
  },
  getUUID() {
    if (crypto == null ? void 0 : crypto.randomUUID) {
      return crypto.randomUUID();
    }
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/AccountController.js
var state2 = proxy({
  isConnected: false
});
var AccountController = {
  state: state2,
  subscribe(callback) {
    return subscribe(state2, () => callback(state2));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state2, key, callback);
  },
  setIsConnected(isConnected) {
    state2.isConnected = isConnected;
  },
  setCaipAddress(caipAddress) {
    state2.caipAddress = caipAddress;
    state2.address = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : void 0;
  },
  setBalance(balance, balanceSymbol) {
    state2.balance = balance;
    state2.balanceSymbol = balanceSymbol;
  },
  setProfileName(profileName) {
    state2.profileName = profileName;
  },
  setProfileImage(profileImage) {
    state2.profileImage = profileImage;
  },
  setAddressExplorerUrl(explorerUrl) {
    state2.addressExplorerUrl = explorerUrl;
  },
  resetAccount() {
    state2.isConnected = false;
    state2.caipAddress = void 0;
    state2.address = void 0;
    state2.balance = void 0;
    state2.balanceSymbol = void 0;
    state2.profileName = void 0;
    state2.profileImage = void 0;
    state2.addressExplorerUrl = void 0;
  }
};

// node_modules/@web3modal/core/dist/esm/src/utils/FetchUtil.js
var FetchUtil = class {
  constructor({ baseUrl: baseUrl4 }) {
    this.baseUrl = baseUrl4;
  }
  async get({ headers, ...args }) {
    const url = this.createUrl(args);
    const response = await fetch(url, { method: "GET", headers });
    return response.json();
  }
  async getBlob({ headers, ...args }) {
    const url = this.createUrl(args);
    const response = await fetch(url, { method: "GET", headers });
    return response.blob();
  }
  async post({ body, headers, ...args }) {
    const url = this.createUrl(args);
    const response = await fetch(url, {
      method: "POST",
      headers,
      body: body ? JSON.stringify(body) : void 0
    });
    return response.json();
  }
  async put({ body, headers, ...args }) {
    const url = this.createUrl(args);
    const response = await fetch(url, {
      method: "PUT",
      headers,
      body: body ? JSON.stringify(body) : void 0
    });
    return response.json();
  }
  async delete({ body, headers, ...args }) {
    const url = this.createUrl(args);
    const response = await fetch(url, {
      method: "DELETE",
      headers,
      body: body ? JSON.stringify(body) : void 0
    });
    return response.json();
  }
  createUrl({ path, params }) {
    const url = new URL(path, this.baseUrl);
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value) {
          url.searchParams.append(key, value);
        }
      });
    }
    return url;
  }
};

// node_modules/@web3modal/core/dist/esm/src/utils/StorageUtil.js
var WC_DEEPLINK = "WALLETCONNECT_DEEPLINK_CHOICE";
var W3M_RECENT = "@w3m/recent";
var W3M_CONNECTED_WALLET_IMAGE_URL = "@w3m/connected_wallet_image_url";
var StorageUtil = {
  setWalletConnectDeepLink({ href, name }) {
    try {
      localStorage.setItem(WC_DEEPLINK, JSON.stringify({ href, name }));
    } catch {
      console.info("Unable to set WalletConnect deep link");
    }
  },
  getWalletConnectDeepLink() {
    try {
      const deepLink = localStorage.getItem(WC_DEEPLINK);
      if (deepLink) {
        return JSON.parse(deepLink);
      }
    } catch {
      console.info("Unable to get WalletConnect deep link");
    }
    return void 0;
  },
  deleteWalletConnectDeepLink() {
    try {
      localStorage.removeItem(WC_DEEPLINK);
    } catch {
      console.info("Unable to delete WalletConnect deep link");
    }
  },
  setWeb3ModalRecent(wallet) {
    try {
      const recentWallets = StorageUtil.getRecentWallets();
      const exists = recentWallets.find((w2) => w2.id === wallet.id);
      if (!exists) {
        recentWallets.unshift(wallet);
        if (recentWallets.length > 2) {
          recentWallets.pop();
        }
        localStorage.setItem(W3M_RECENT, JSON.stringify(recentWallets));
      }
    } catch {
      console.info("Unable to set Web3Modal recent");
    }
  },
  getRecentWallets() {
    try {
      const recent = localStorage.getItem(W3M_RECENT);
      return recent ? JSON.parse(recent) : [];
    } catch {
      console.info("Unable to get Web3Modal recent");
    }
    return [];
  },
  setConnectedWalletImageUrl(imageUrl) {
    try {
      localStorage.setItem(W3M_CONNECTED_WALLET_IMAGE_URL, imageUrl);
    } catch {
      console.info("Unable to set Connected Wallet Image Url");
    }
  },
  getConnectedWalletImageUrl() {
    try {
      return localStorage.getItem(W3M_CONNECTED_WALLET_IMAGE_URL);
    } catch {
      console.info("Unable to set Connected Wallet Image Url");
    }
    return void 0;
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/AssetController.js
var state3 = proxy({
  walletImages: {},
  networkImages: {},
  connectorImages: {},
  tokenImages: {}
});
var AssetController = {
  state: state3,
  subscribeNetworkImages(callback) {
    return subscribe(state3.networkImages, () => callback(state3.networkImages));
  },
  subscribeKey(key, callback) {
    return subscribeKey(state3, key, callback);
  },
  setWalletImage(key, value) {
    state3.walletImages[key] = value;
  },
  setNetworkImage(key, value) {
    state3.networkImages[key] = value;
  },
  setConnectorImage(key, value) {
    state3.connectorImages[key] = value;
  },
  setTokenImage(key, value) {
    state3.tokenImages[key] = value;
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/ConnectorController.js
var state4 = proxy({
  connectors: []
});
var ConnectorController = {
  state: state4,
  subscribeKey(key, callback) {
    return subscribeKey(state4, key, callback);
  },
  setConnectors(connectors) {
    state4.connectors = connectors.map((c) => ref(c));
  },
  addConnector(connector) {
    state4.connectors.push(ref(connector));
  },
  getConnectors() {
    return state4.connectors;
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/PublicStateController.js
var state5 = proxy({
  open: false,
  selectedNetworkId: void 0
});
var PublicStateController = {
  state: state5,
  subscribe(callback) {
    return subscribe(state5, () => callback(state5));
  },
  set(newState) {
    Object.assign(state5, { ...state5, ...newState });
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/NetworkController.js
var state6 = proxy({
  supportsAllNetworks: true,
  isDefaultCaipNetwork: false
});
var NetworkController = {
  state: state6,
  subscribeKey(key, callback) {
    return subscribeKey(state6, key, callback);
  },
  _getClient() {
    if (!state6._client) {
      throw new Error("NetworkController client not set");
    }
    return state6._client;
  },
  setClient(client) {
    state6._client = ref(client);
  },
  setCaipNetwork(caipNetwork) {
    state6.caipNetwork = caipNetwork;
    PublicStateController.set({ selectedNetworkId: caipNetwork == null ? void 0 : caipNetwork.id });
  },
  setDefaultCaipNetwork(caipNetwork) {
    state6.caipNetwork = caipNetwork;
    PublicStateController.set({ selectedNetworkId: caipNetwork == null ? void 0 : caipNetwork.id });
    state6.isDefaultCaipNetwork = true;
  },
  setRequestedCaipNetworks(requestedNetworks) {
    state6.requestedCaipNetworks = requestedNetworks;
  },
  async getApprovedCaipNetworksData() {
    const data = await this._getClient().getApprovedCaipNetworksData();
    state6.supportsAllNetworks = data.supportsAllNetworks;
    state6.approvedCaipNetworkIds = data.approvedCaipNetworkIds;
  },
  async switchActiveNetwork(network) {
    await this._getClient().switchCaipNetwork(network);
    state6.caipNetwork = network;
  },
  resetNetwork() {
    if (!state6.isDefaultCaipNetwork) {
      state6.caipNetwork = void 0;
    }
    state6.approvedCaipNetworkIds = void 0;
    state6.supportsAllNetworks = true;
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/OptionsController.js
var state7 = proxy({
  projectId: "",
  sdkType: "w3m",
  sdkVersion: "html-wagmi-undefined"
});
var OptionsController = {
  state: state7,
  subscribeKey(key, callback) {
    return subscribeKey(state7, key, callback);
  },
  setProjectId(projectId) {
    state7.projectId = projectId;
  },
  setIncludeWalletIds(includeWalletIds) {
    state7.includeWalletIds = includeWalletIds;
  },
  setExcludeWalletIds(excludeWalletIds) {
    state7.excludeWalletIds = excludeWalletIds;
  },
  setFeaturedWalletIds(featuredWalletIds) {
    state7.featuredWalletIds = featuredWalletIds;
  },
  setTokens(tokens) {
    state7.tokens = tokens;
  },
  setTermsConditionsUrl(termsConditionsUrl) {
    state7.termsConditionsUrl = termsConditionsUrl;
  },
  setPrivacyPolicyUrl(privacyPolicyUrl) {
    state7.privacyPolicyUrl = privacyPolicyUrl;
  },
  setCustomWallets(customWallets) {
    state7.customWallets = customWallets;
  },
  setEnableAnalytics(enableAnalytics) {
    state7.enableAnalytics = enableAnalytics;
  },
  setSdkVersion(sdkVersion) {
    state7.sdkVersion = sdkVersion;
  },
  setMetadata(metadata) {
    state7.metadata = metadata;
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/ApiController.js
var baseUrl = CoreHelperUtil.getApiUrl();
var api = new FetchUtil({ baseUrl });
var entries = "40";
var recommendedEntries = "4";
var state8 = proxy({
  page: 1,
  count: 0,
  featured: [],
  recommended: [],
  wallets: [],
  search: []
});
var ApiController = {
  state: state8,
  subscribeKey(key, callback) {
    return subscribeKey(state8, key, callback);
  },
  _getApiHeaders() {
    const { projectId, sdkType, sdkVersion } = OptionsController.state;
    return {
      "x-project-id": projectId,
      "x-sdk-type": sdkType,
      "x-sdk-version": sdkVersion
    };
  },
  async _fetchWalletImage(imageId) {
    const imageUrl = `${api.baseUrl}/getWalletImage/${imageId}`;
    const blob = await api.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setWalletImage(imageId, URL.createObjectURL(blob));
  },
  async _fetchNetworkImage(imageId) {
    const imageUrl = `${api.baseUrl}/public/getAssetImage/${imageId}`;
    const blob = await api.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setNetworkImage(imageId, URL.createObjectURL(blob));
  },
  async _fetchConnectorImage(imageId) {
    const imageUrl = `${api.baseUrl}/public/getAssetImage/${imageId}`;
    const blob = await api.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setConnectorImage(imageId, URL.createObjectURL(blob));
  },
  async fetchNetworkImages() {
    const { requestedCaipNetworks } = NetworkController.state;
    const ids = requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.map(({ imageId }) => imageId).filter(Boolean);
    if (ids) {
      await Promise.allSettled(ids.map((id) => ApiController._fetchNetworkImage(id)));
    }
  },
  async fetchConnectorImages() {
    const { connectors } = ConnectorController.state;
    const ids = connectors.map(({ imageId }) => imageId).filter(Boolean);
    await Promise.allSettled(ids.map((id) => ApiController._fetchConnectorImage(id)));
  },
  async fetchFeaturedWallets() {
    const { featuredWalletIds } = OptionsController.state;
    if (featuredWalletIds == null ? void 0 : featuredWalletIds.length) {
      const { data } = await api.get({
        path: "/getWallets",
        headers: ApiController._getApiHeaders(),
        params: {
          page: "1",
          entries: (featuredWalletIds == null ? void 0 : featuredWalletIds.length) ? String(featuredWalletIds.length) : recommendedEntries,
          include: featuredWalletIds == null ? void 0 : featuredWalletIds.join(",")
        }
      });
      data.sort((a2, b) => featuredWalletIds.indexOf(a2.id) - featuredWalletIds.indexOf(b.id));
      const images = data.map((d) => d.image_id).filter(Boolean);
      await Promise.allSettled(images.map((id) => ApiController._fetchWalletImage(id)));
      state8.featured = data;
    }
  },
  async fetchRecommendedWallets() {
    const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
    const exclude = [...excludeWalletIds ?? [], ...featuredWalletIds ?? []].filter(Boolean);
    const { data, count } = await api.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: "1",
        entries: recommendedEntries,
        include: includeWalletIds == null ? void 0 : includeWalletIds.join(","),
        exclude: exclude == null ? void 0 : exclude.join(",")
      }
    });
    const recent = StorageUtil.getRecentWallets();
    const recommendedImages = data.map((d) => d.image_id).filter(Boolean);
    const recentImages = recent.map((r) => r.image_id).filter(Boolean);
    await Promise.allSettled([...recommendedImages, ...recentImages].map((id) => ApiController._fetchWalletImage(id)));
    state8.recommended = data;
    state8.count = count ?? 0;
  },
  async fetchWallets({ page }) {
    const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
    const exclude = [
      ...state8.recommended.map(({ id }) => id),
      ...excludeWalletIds ?? [],
      ...featuredWalletIds ?? []
    ].filter(Boolean);
    const { data, count } = await api.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: String(page),
        entries,
        include: includeWalletIds == null ? void 0 : includeWalletIds.join(","),
        exclude: exclude.join(",")
      }
    });
    const images = data.map((w2) => w2.image_id).filter(Boolean);
    await Promise.allSettled([
      ...images.map((id) => ApiController._fetchWalletImage(id)),
      CoreHelperUtil.wait(300)
    ]);
    state8.wallets = [...state8.wallets, ...data];
    state8.count = count > state8.count ? count : state8.count;
    state8.page = page;
  },
  async searchWallet({ search }) {
    const { includeWalletIds, excludeWalletIds } = OptionsController.state;
    state8.search = [];
    const { data } = await api.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: "1",
        entries: "100",
        search,
        include: includeWalletIds == null ? void 0 : includeWalletIds.join(","),
        exclude: excludeWalletIds == null ? void 0 : excludeWalletIds.join(",")
      }
    });
    const images = data.map((w2) => w2.image_id).filter(Boolean);
    await Promise.allSettled([
      ...images.map((id) => ApiController._fetchWalletImage(id)),
      CoreHelperUtil.wait(300)
    ]);
    state8.search = data;
  },
  prefetch() {
    state8.prefetchPromise = Promise.race([
      Promise.allSettled([
        ApiController.fetchFeaturedWallets(),
        ApiController.fetchRecommendedWallets(),
        ApiController.fetchNetworkImages(),
        ApiController.fetchConnectorImages()
      ]),
      CoreHelperUtil.wait(3e3)
    ]);
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/EventsController.js
var baseUrl2 = CoreHelperUtil.getAnalyticsUrl();
var api2 = new FetchUtil({ baseUrl: baseUrl2 });
var excluded = ["MODAL_CREATED"];
var state9 = proxy({
  timestamp: Date.now(),
  data: {
    type: "track",
    event: "MODAL_CREATED"
  }
});
var EventsController = {
  state: state9,
  subscribe(callback) {
    return subscribe(state9, () => callback(state9));
  },
  _getApiHeaders() {
    const { projectId, sdkType, sdkVersion } = OptionsController.state;
    return {
      "x-project-id": projectId,
      "x-sdk-type": sdkType,
      "x-sdk-version": sdkVersion
    };
  },
  async _sendAnalyticsEvent(payload) {
    try {
      if (excluded.includes(payload.data.event) || typeof window === "undefined") {
        return;
      }
      await api2.post({
        path: "/e",
        headers: EventsController._getApiHeaders(),
        body: {
          eventId: CoreHelperUtil.getUUID(),
          url: window.location.href,
          domain: window.location.hostname,
          timestamp: payload.timestamp,
          props: payload.data
        }
      });
    } catch {
    }
  },
  sendEvent(data) {
    state9.timestamp = Date.now();
    state9.data = data;
    if (OptionsController.state.enableAnalytics) {
      EventsController._sendAnalyticsEvent(state9);
    }
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/RouterController.js
var state10 = proxy({
  view: "Connect",
  history: ["Connect"]
});
var RouterController = {
  state: state10,
  subscribeKey(key, callback) {
    return subscribeKey(state10, key, callback);
  },
  push(view, data) {
    if (view !== state10.view) {
      state10.view = view;
      state10.history.push(view);
      state10.data = data;
    }
  },
  reset(view) {
    state10.view = view;
    state10.history = [view];
  },
  replace(view) {
    if (state10.history.length > 1 && state10.history.at(-1) !== view) {
      state10.view = view;
      state10.history[state10.history.length - 1] = view;
    }
  },
  goBack() {
    if (state10.history.length > 1) {
      state10.history.pop();
      const [last] = state10.history.slice(-1);
      if (last) {
        state10.view = last;
      }
    }
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/ModalController.js
var state11 = proxy({
  open: false
});
var ModalController = {
  state: state11,
  subscribeKey(key, callback) {
    return subscribeKey(state11, key, callback);
  },
  async open(options) {
    await ApiController.state.prefetchPromise;
    if (options == null ? void 0 : options.view) {
      RouterController.reset(options.view);
    } else if (AccountController.state.isConnected) {
      RouterController.reset("Account");
    } else {
      RouterController.reset("Connect");
    }
    state11.open = true;
    PublicStateController.set({ open: true });
    EventsController.sendEvent({ type: "track", event: "MODAL_OPEN" });
  },
  close() {
    state11.open = false;
    PublicStateController.set({ open: false });
    EventsController.sendEvent({ type: "track", event: "MODAL_CLOSE" });
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/BlockchainApiController.js
var baseUrl3 = CoreHelperUtil.getBlockchainApiUrl();
var api3 = new FetchUtil({ baseUrl: baseUrl3 });
var BlockchainApiController = {
  fetchIdentity({ caipChainId, address }) {
    return api3.get({
      path: `/v1/identity/${address}`,
      params: {
        chainId: caipChainId,
        projectId: OptionsController.state.projectId
      }
    });
  },
  fetchTransactions({ account, projectId, cursor }) {
    const queryParams = cursor ? { cursor } : {};
    return api3.get({
      path: `/v1/account/${account}/history?projectId=${projectId}`,
      params: queryParams
    });
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/SnackController.js
var state12 = proxy({
  message: "",
  variant: "success",
  open: false
});
var SnackController = {
  state: state12,
  subscribeKey(key, callback) {
    return subscribeKey(state12, key, callback);
  },
  showSuccess(message) {
    state12.message = message;
    state12.variant = "success";
    state12.open = true;
  },
  showError(message) {
    state12.message = message;
    state12.variant = "error";
    state12.open = true;
  },
  hide() {
    state12.open = false;
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/TransactionsController.js
var state13 = proxy({
  transactions: [],
  transactionsByYear: {},
  loading: false,
  empty: false,
  next: void 0
});
var TransactionsController = {
  state: state13,
  subscribe(callback) {
    return subscribe(state13, () => callback(state13));
  },
  async fetchTransactions(accountAddress) {
    const { projectId } = OptionsController.state;
    if (!projectId || !accountAddress) {
      throw new Error("Transactions can't be fetched without a projectId and an accountAddress");
    }
    state13.loading = true;
    try {
      const response = await BlockchainApiController.fetchTransactions({
        account: accountAddress,
        projectId,
        cursor: state13.next
      });
      const nonSpamTransactions = this.filterSpamTransactions(response.data);
      const filteredTransactions = [...state13.transactions, ...nonSpamTransactions];
      state13.loading = false;
      state13.transactions = filteredTransactions;
      state13.transactionsByYear = this.groupTransactionsByYear(state13.transactionsByYear, nonSpamTransactions);
      state13.empty = filteredTransactions.length === 0;
      state13.next = response.next ? response.next : void 0;
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "ERROR_FETCH_TRANSACTIONS",
        properties: {
          address: accountAddress,
          projectId,
          cursor: state13.next
        }
      });
      SnackController.showError("Failed to fetch transactions");
      state13.loading = false;
      state13.empty = true;
    }
  },
  groupTransactionsByYear(transactionsMap = {}, transactions = []) {
    const grouped = transactionsMap;
    transactions.forEach((transaction) => {
      var _a;
      const year = new Date(transaction.metadata.minedAt).getFullYear();
      if (!grouped[year]) {
        grouped[year] = [];
      }
      (_a = grouped[year]) == null ? void 0 : _a.push(transaction);
    });
    return grouped;
  },
  filterSpamTransactions(transactions) {
    return transactions.filter((transaction) => {
      const isAllSpam = transaction.transfers.every((transfer) => {
        var _a;
        return ((_a = transfer.nft_info) == null ? void 0 : _a.flags.is_spam) === true;
      });
      return !isAllSpam;
    });
  },
  resetTransactions() {
    state13.transactions = [];
    state13.transactionsByYear = {};
    state13.loading = false;
    state13.empty = false;
    state13.next = void 0;
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/ConnectionController.js
var state14 = proxy({
  wcError: false,
  buffering: false
});
var ConnectionController = {
  state: state14,
  subscribeKey(key, callback) {
    return subscribeKey(state14, key, callback);
  },
  _getClient() {
    if (!state14._client) {
      throw new Error("ConnectionController client not set");
    }
    return state14._client;
  },
  setClient(client) {
    state14._client = ref(client);
  },
  connectWalletConnect() {
    state14.wcPromise = this._getClient().connectWalletConnect((uri) => {
      state14.wcUri = uri;
      state14.wcPairingExpiry = CoreHelperUtil.getPairingExpiry();
    });
  },
  async connectExternal(options) {
    var _a, _b;
    await ((_b = (_a = this._getClient()).connectExternal) == null ? void 0 : _b.call(_a, options));
  },
  checkInstalled(ids) {
    var _a, _b;
    return (_b = (_a = this._getClient()).checkInstalled) == null ? void 0 : _b.call(_a, ids);
  },
  resetWcConnection() {
    state14.wcUri = void 0;
    state14.wcPairingExpiry = void 0;
    state14.wcPromise = void 0;
    state14.wcLinking = void 0;
    state14.recentWallet = void 0;
    TransactionsController.resetTransactions();
    StorageUtil.deleteWalletConnectDeepLink();
  },
  setWcLinking(wcLinking) {
    state14.wcLinking = wcLinking;
  },
  setWcError(wcError) {
    state14.wcError = wcError;
    state14.buffering = false;
  },
  setRecentWallet(wallet) {
    state14.recentWallet = wallet;
  },
  setBuffering(buffering) {
    state14.buffering = buffering;
  },
  async disconnect() {
    await this._getClient().disconnect();
    this.resetWcConnection();
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/SIWEController.js
var state15 = proxy({
  status: "uninitialized"
});
var SIWEController = {
  state: state15,
  subscribeKey(key, callback) {
    return subscribeKey(state15, key, callback);
  },
  subscribe(callback) {
    return subscribe(state15, () => callback(state15));
  },
  _getClient() {
    if (!state15._client) {
      throw new Error("SIWEController client not set");
    }
    return state15._client;
  },
  setSIWEClient(client) {
    state15._client = ref(client);
    state15.status = "ready";
  },
  setNonce(nonce) {
    state15.nonce = nonce;
  },
  setStatus(status) {
    state15.status = status;
  },
  setMessage(message) {
    state15.message = message;
  },
  setSession(session) {
    state15.session = session;
  }
};

// node_modules/@web3modal/core/dist/esm/src/controllers/ThemeController.js
var state16 = proxy({
  themeMode: "dark",
  themeVariables: {}
});
var ThemeController = {
  state: state16,
  subscribe(callback) {
    return subscribe(state16, () => callback(state16));
  },
  setThemeMode(themeMode) {
    state16.themeMode = themeMode;
  },
  setThemeVariables(themeVariables) {
    state16.themeVariables = { ...state16.themeVariables, ...themeVariables };
  }
};

// node_modules/@web3modal/core/dist/esm/src/utils/AssetUtil.js
var AssetUtil = {
  getWalletImage(wallet) {
    if (wallet == null ? void 0 : wallet.image_url) {
      return wallet == null ? void 0 : wallet.image_url;
    }
    if (wallet == null ? void 0 : wallet.image_id) {
      return AssetController.state.walletImages[wallet.image_id];
    }
    return void 0;
  },
  getNetworkImage(network) {
    if (network == null ? void 0 : network.imageUrl) {
      return network == null ? void 0 : network.imageUrl;
    }
    if (network == null ? void 0 : network.imageId) {
      return AssetController.state.networkImages[network.imageId];
    }
    return void 0;
  },
  getConnectorImage(connector) {
    if (connector == null ? void 0 : connector.imageUrl) {
      return connector.imageUrl;
    }
    if (connector == null ? void 0 : connector.imageId) {
      return AssetController.state.connectorImages[connector.imageId];
    }
    return void 0;
  }
};

// node_modules/@web3modal/scaffold/dist/esm/src/modal/w3m-modal/styles.js
var styles_default = css`
  :host {
    z-index: var(--w3m-z-index);
    display: block;
    backface-visibility: hidden;
    will-change: opacity;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    opacity: 0;
    background-color: var(--wui-cover);
  }

  @keyframes zoom-in {
    0% {
      transform: scale(0.95) translateY(0);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  @keyframes slide-in {
    0% {
      transform: scale(1) translateY(50px);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  wui-card {
    max-width: 360px;
    width: 100%;
    position: relative;
    animation-delay: 0.3s;
    animation-duration: 0.2s;
    animation-name: zoom-in;
    animation-fill-mode: backwards;
    animation-timing-function: var(--wui-ease-out-power-2);
    outline: none;
  }

  wui-flex {
    overflow-x: hidden;
    overflow-y: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
  }

  @media (max-height: 700px) and (min-width: 431px) {
    wui-flex {
      align-items: flex-start;
    }

    wui-card {
      margin: var(--wui-spacing-xxl) 0px;
    }
  }

  @media (max-width: 430px) {
    wui-flex {
      align-items: flex-end;
    }

    wui-card {
      max-width: 100%;
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      border-bottom: none;
      animation-name: slide-in;
    }
  }
`;

// node_modules/@web3modal/scaffold/dist/esm/src/modal/w3m-modal/index.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SCROLL_LOCK = "scroll-lock";
var W3mModal = class W3mModal2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.abortController = void 0;
    this.open = ModalController.state.open;
    this.initializeTheming();
    ApiController.prefetch();
    this.unsubscribe.push(ModalController.subscribeKey("open", (val) => val ? this.onOpen() : this.onClose()));
    EventsController.sendEvent({ type: "track", event: "MODAL_LOADED" });
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    this.onRemoveKeyboardListener();
  }
  render() {
    return this.open ? html`
          <wui-flex @click=${this.onOverlayClick.bind(this)}>
            <wui-card role="alertdialog" aria-modal="true" tabindex="0">
              <w3m-header></w3m-header>
              <w3m-router></w3m-router>
              <w3m-snackbar></w3m-snackbar>
            </wui-card>
          </wui-flex>
        ` : null;
  }
  onOverlayClick(event) {
    if (event.target === event.currentTarget) {
      ModalController.close();
    }
  }
  initializeTheming() {
    const { themeVariables, themeMode } = ThemeController.state;
    const defaultThemeMode = UiHelperUtil.getColorTheme(themeMode);
    initializeTheming(themeVariables, defaultThemeMode);
  }
  async onClose() {
    this.onScrollUnlock();
    await this.animate([{ opacity: 1 }, { opacity: 0 }], {
      duration: 200,
      easing: "ease",
      fill: "forwards"
    }).finished;
    SnackController.hide();
    this.open = false;
    this.onRemoveKeyboardListener();
  }
  async onOpen() {
    this.onScrollLock();
    this.open = true;
    await this.animate([{ opacity: 0 }, { opacity: 1 }], {
      duration: 200,
      easing: "ease",
      fill: "forwards",
      delay: 300
    }).finished;
    this.onAddKeyboardListener();
  }
  onScrollLock() {
    const styleTag = document.createElement("style");
    styleTag.dataset["w3m"] = SCROLL_LOCK;
    styleTag.textContent = `
      html, body {
        touch-action: none;
        overflow: hidden;
        overscroll-behavior: contain;
      }
      w3m-modal {
        pointer-events: auto;
      }
    `;
    document.head.appendChild(styleTag);
  }
  onScrollUnlock() {
    const styleTag = document.head.querySelector(`style[data-w3m="${SCROLL_LOCK}"]`);
    if (styleTag) {
      styleTag.remove();
    }
  }
  onAddKeyboardListener() {
    var _a;
    this.abortController = new AbortController();
    const card = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector("wui-card");
    card == null ? void 0 : card.focus();
    window.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        ModalController.close();
      } else if (event.key === "Tab") {
        const { tagName } = event.target;
        if (tagName && !tagName.includes("W3M-") && !tagName.includes("WUI-")) {
          card == null ? void 0 : card.focus();
        }
      }
    }, this.abortController);
  }
  onRemoveKeyboardListener() {
    var _a;
    (_a = this.abortController) == null ? void 0 : _a.abort();
    this.abortController = void 0;
  }
};
W3mModal.styles = styles_default;
__decorate([
  state()
], W3mModal.prototype, "open", void 0);
W3mModal = __decorate([
  customElement("w3m-modal")
], W3mModal);

export {
  ConstantsUtil,
  CoreHelperUtil,
  AccountController,
  StorageUtil,
  AssetController,
  ConnectorController,
  PublicStateController,
  NetworkController,
  OptionsController,
  ApiController,
  EventsController,
  RouterController,
  ModalController,
  BlockchainApiController,
  SnackController,
  TransactionsController,
  ConnectionController,
  SIWEController,
  ThemeController,
  AssetUtil,
  W3mModal
};
//# sourceMappingURL=chunk-ZU56MPA6.js.map
